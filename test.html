<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
	<canvas class="myCanvas">
	  <p>Add suitable fallback here.</p>
	</canvas>
    <script>
		const canvas = document.querySelector('.myCanvas');
		const width = canvas.width = window.innerWidth;
		const height = canvas.height = window.innerHeight;
		const ctx = canvas.getContext('2d');
		var runGame = true;
		var pacman = {x:70, y:70};
		var blocks = [];

		drawBackground();
		drawPacman();
		
		setTimeout(loop, 0);
		
		async function loop() {
			d = 1;
			initGame();
			while (runGame ) {
				drawBackground();
				drawPacman();
				await sleep(25);
			};
		};
		
		function initGame() {
			drawBackground();
			createBlock(80, 80, 100, 100);
			createBlock(80, 200, 100, 200);
			createBlock(200, 80, 100, 200);
			createBlock(200, 300, 220, 100);
			createBlock(320, 80, 100, 200);
		}
		
		function sleep(ms) {
			return new Promise(resolve => setTimeout(resolve, ms));
		}
		
		
		document.onkeydown = function(evt) {
			evt = evt || window.event;
			if (evt.keyCode == 27) {
				runGame = false;
			}
			if (event.key === "ArrowRight") {
				checkAndMovePacman(pman => {return  {...pman, x : (pman.x + 10)};});
			}
			if (event.key === "ArrowLeft") {
				checkAndMovePacman(pman => {return  {...pman, x : (pman.x - 10)};});
			}
			if (event.key === "ArrowDown") {
				checkAndMovePacman(pman => {return  {...pman, y : (pman.y + 10)};});
			}
			if (event.key === "ArrowUp") {
				checkAndMovePacman(pman => {return  {...pman, y : (pman.y - 10)};});
			}
		};
		
		function checkAndMovePacman(moveFunction) {
			let newPacman = moveFunction(pacman);
			if (!checkIfPacmanCollides(newPacman)) {
				pacman = newPacman;
			}
		}
		
		function checkIfPacmanCollides( newPacman) {
			return blocks.map((block) => packmanCollidesWithBlock(newPacman, block) ).reduce((any, current) => current || any);
		};
		
		function packmanCollidesWithBlock(pman, block) {
			console.log("Check called for block ", block);
			let values = [[pman.x - 9, pman.y - 9],
				[pman.x + 9, pman.y - 9],
				[pman.x - 9, pman.y + 9],
				[pman.x + 9, pman.y + 9]
			];
			console.log("Edges: ", values);
			let result = values.reduce(
				(any, current) => pointIsInRectangle(...current, block.startX, block.startY, block.lenX, block.lenY) || any, false);
			console.log(result);
			return result;
		}
		
		function pointIsInRectangle(x, y, rectStartX, rectStartY, rectLenX, rectLenY) {
			let values = [
				x > rectStartX,
				x < rectStartX + rectLenX,
				y > rectStartY,
				y < rectStartY + rectLenY
			];
			console.log(values);
			let result = values.reduce((any, current) => current && any, true);
			console.log(result);
			if (result) console.log(`Point ${[x,y]} is in rectangle ${[rectStartX, rectStartY, rectLenX, rectLenY]}`);
			return result;
		};
		
		
		
		function degToRad(degrees) {
		  return degrees * Math.PI / 180;
		};
		
		function drawBackground(){
			ctx.fillStyle = 'rgb(0,255,0)';//green
			ctx.fillRect(0,0,width,height);
			
			ctx.fillStyle = 'rgb(255, 0, 0)';
			ctx.fillRect(50,50,550,550);
			
			ctx.fillStyle = 'rgb(0,255,0)';//green
			ctx.fillRect(60,60,530,530);
			-
			drawBlocks();
		};
		
		function drawBlocks() {
			blocks.map( block => {
					ctx.fillStyle = 'rgb(255, 0, 0)';
					ctx.fillRect(block.startX, block.startY, block.lenX, block.lenY);
				}
			);
		};
		
		function createBlock(startX, startY, lenX, lenY) {
			blocks = [...blocks, {startX:startX, startY:startY, lenX:lenX, lenY:lenY}];
			console.log(`Block createad at ${startX}, ${startY}, ${lenX}, ${lenY} `);
		};
		
		function drawPacman() {
			ctx.fillStyle = 'yellow';
			ctx.beginPath();
			ctx.arc(pacman.x, pacman.y, 9, degToRad(-45), degToRad(45), true);
			ctx.lineTo(pacman.x, pacman.y);
			ctx.fill();
		};
		
    </script>
  </body>
</html>
